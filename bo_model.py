# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt

DATA_CSV_PATH = "PATH/TO/your_data.csv"

PARAM_ALIASES = {
    "Organic/Aqueous composition (V/V)": "x1",
    "Stirring speed": "x2",
    "Stirring duration": "x3",
    "Aqueous solution (5 neutral, 5 basic, 5 acidic, ...)": "c1",
    "Temperature": "temp",
    "pH": "pH",
}

Y_COLS = {
    "aq_recovery": "Recovery of aq",
    "aq_purity": "Purity of aq",
    "or_recovery": "Recovery of or",
    "or_purity": "Purity of or",
    "separation_time": "Separation",
    "partition_coefficient": "Partition coefficient (PC)",
}

# Define the objectives
obj1_name = "aq_recovery"
obj2_name = "aq_purity"
obj3_name = "or_recovery"
obj4_name = "or_purity"
obj5_name = "separation_time"
obj6_name = "partition_coefficient"

Y_COLS_REQUIRED = {
    obj1_name: Y_COLS["aq_recovery"],
    obj2_name: Y_COLS["aq_purity"],
    obj3_name: Y_COLS["or_recovery"],
    obj4_name: Y_COLS["or_purity"],
    obj5_name: Y_COLS["separation_time"],
    obj6_name: Y_COLS["partition_coefficient"],
}

# ---------------------------
# READ DATA FROM CSV
# ---------------------------
df = pd.read_csv(DATA_CSV_PATH)

# Build X_train by selecting and renaming only the mapped columns
raw_x_cols = list(PARAM_ALIASES.keys())
X_train = df[raw_x_cols].rename(columns=PARAM_ALIASES).copy()
if "c1" in X_train.columns:
    X_train["c1"] = X_train["c1"].astype(str)

# Build y_train as a list of dicts containing ONLY the objectives declared in the experiment
y_train = []
for _, row in df.iterrows():
    y_entry = {obj_name: row[col_name] for obj_name, col_name in Y_COLS_REQUIRED.items()}
    y_train.append(y_entry)

n_train = len(X_train)

# ---------------------------
# BO SETUP
# ---------------------------
ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, TOTAL]},
        {"name": "x2", "type": "range", "bounds": [0.0, TOTAL]},
        {"name": "x3", "type": "range", "bounds": [0.0, TOTAL]},
        {
            "name": "c1",
            "type": "choice",
            "is_ordered": False,
            "values": ["A", "B", "C"], # Check these categorical variables with eric
        },
        {"name": "temp", "type": "range", "bounds": [LOWER_TEMP, UPPER_TEMP]},
        {"name": "pH", "type": "range", "bounds": [LOWER_PH, UPPER_PH]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True), # check these again
        obj2_name: ObjectiveProperties(minimize=True),
        obj3_name: ObjectiveProperties(minimize=True),
        obj4_name: ObjectiveProperties(minimize=True),
        obj5_name: ObjectiveProperties(minimize=True),
        obj6_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[],
)

# ---------------------------
# SEED WITH EXISTING (CSV) DATA
# ---------------------------
for i in range(n_train):
    parameterization = X_train.iloc[i].to_dict()
    # If using the composition constraint, hide x3 from the modelled space:
    parameterization.pop("x3", None)

    ax_client.attach_trial(parameterization)
    ax_client.complete_trial(trial_index=i, raw_data=y_train[i])

# ---------------------------
# SUGGEST & EVALUATE NEW TRIALS
# ---------------------------
for _ in range(23):
    parameterization, trial_index = ax_client.get_next_trial()

    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = TOTAL - (x1 + x2)  # enforce composition
    c1 = parameterization["c1"]

    results = branin3_moo(x1, x2, x3, c1)  # MUST return a dict of objective -> value
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

pareto_results = ax_client.get_pareto_optimal_parameters()

# ---------------------------
# PLOT RESULTS
# ---------------------------
objectives = ax_client.objective_names
df_ax = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df_ax[objectives[0]], df_ax[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(pareto[objectives[0]], pareto[objectives[1]], lw=2, label="Pareto Front")
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])
ax.legend()
plt.show()
